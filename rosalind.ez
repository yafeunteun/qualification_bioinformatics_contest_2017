/*_________________________________________________________

onemax.ez // Evolve individuals containing 111111111111111111...
__________________________________________________________*/


\User declarations :
#include<fstream>
#include<iostream>
#include<string>
#include<iterator>
#include<algorithm>
#include "assert.h"

#define N_READS 7
#define DNA_SIZE 8


int SIZE = 0;
vector<string> READS = vector<string>();
string DNA = "";

float pMutPerGene=0.1;
\end

\User functions:
// Returns first position of char `c` in `dna`
// starting at position `start_pos`. -1 if not found.
int find_pos(string& dna, char c, int start_pos) {
  for (int i = start_pos; i < dna.length(); i++) {
    if (dna[i] == c) return i;
  }
  return -1;
}

// Returns position of the last char of `read` in `dna`
// starting at position `start_pos`. -1 if not found.
int is_substring(string& dna, string& read, int start_pos) {
  int last_pos = -1;
  for (int i = 0; i < read.length(); i++) {
    int pos = find_pos(dna, read[i], start_pos);
    if (pos == -1) return -1;
    start_pos = pos + 1;
    last_pos = pos;
  }
  return last_pos;
}
\end

\User CUDA:
\end

\Before everything else function:
if (argc != 2) {
  cout << "USAGE: ./rosalind FILE" << endl;
  exit(1);
}

ifstream infile(argv[1]);
infile >> DNA;
infile >> SIZE;
string line;
while ( getline(infile, line)) {
  if (line.length() > 0) {
    READS.push_back(line);
  }
}

assert(READS.size() == SIZE);

cout << "DNA <- " << DNA << endl;
cout << "SIZE <- " << SIZE << endl;
cout << "READS LONGUEUR" << READS.size() << endl;
for (int i = 0; i < READS.size(); i++) {
  cout << "READ " << i << " " << READS[i] << endl;
}

if (READS.size() != N_READS) {
  cout << "\n\nPLEASE EDIT N_READS TO MATCH THE NUMBER OF READS IN FILE: " << READS.size() << endl;
  exit(1);
}

\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass { 
  int read_positions[N_READS];
  int solutions[N_READS];
  int coding_bits[DNA_SIZE];
}
\end

\GenomeClass::display:
cout << "coucouille" << endl;
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  for(int i=0; i<SIZE; i++ ) {
    Genome.read_positions[i] = i;
  }
  random_shuffle(begin(Genome.read_positions), end(Genome.read_positions));
  for(int i=0; i<DNA_SIZE; i++ )
     	Genome.coding_bits[i] = random(0,2);
\end

\GenomeClass::crossover :

 int nLocus=random(1,DNA_SIZE);

  for (int i=nLocus;i<DNA_SIZE;i++)
     child.coding_bits[i]=parent2.coding_bits[i];
\end

\GenomeClass::mutator : // Must return a value (for historical reasons)
for (int i=0;i<DNA_SIZE;i++)
    if (tossCoin(pMutPerGene)) Genome.coding_bits[i]=(Genome.coding_bits[i]+1)%2;
  return 3;


\end

\GenomeClass::evaluator : // Returns the score
  float fScore = 0;
  int cursor = 0;

  for (int i = 0; i < SIZE; i++) {
    int read_idx = Genome.read_positions[i];
    int pos = is_substring(DNA, READS[read_idx], cursor);
    if (pos == -1) {
      Genome.solutions[i] = -1;
    } else {
      fScore++;
      Genome.solutions[i] = 1;
      cursor = pos + 1;
    }
  }

  return fScore;
\end

\User Makefile options:
CXXFLAGS+=-std=c++11
\end

\Default run parameters :           // Please let the parameters appear in this order
  Number of generations : 10000     // NB_GEN
  Time limit: 0                     // In seconds, 0 to deactivate
  Population size : 1000            // POP_SIZE
  Offspring size : 100              // 40% 
  Mutation probability : 1          // MUT_PROB
  Crossover probability : 0.2       // XOVER_PROB
  Evaluator goal : maximise         // Maximise
  Selection operator: Tournament 2
  Surviving parents: 1              // Percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong                   // Weak or Strong
  Elite: 1
  Print stats: true
  Generate csv stats file: false			
  Generate gnuplot script: false
  Generate R script: false
  Plot stats: false

  Remote island model: false
  IP file: ip.txt                   // File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.3

  Save population: true
  Start from file: false
\end
