/*_________________________________________________________

onemax.ez // Evolve individuals containing 111111111111111111...
__________________________________________________________*/


\User declarations :
#include<fstream>
#include<iostream>
#include<string>
#include<iterator>
#include<algorithm>
#include "assert.h"

#define N_READS 1000
#define DNA_SIZE 1091921


int SIZE = 0;
vector<string> READS = vector<string>();
string DNA = "";

float pMutPerGene=0.1;
\end

\User functions:

// Check if in an array describing start and end positions,
// The overlaps are correct regarding of our problem
/ return true if the overlaps are valids and false else.
// IMPORTANT: in our case `size` must be set to 2*SIZE
bool check_overlaps(int** tab, int size){
  for (int i = 2; i < size; i+=2) {
    if (!(tab[i-2] < tab[i] and tab[i] < tab[i-1])) {
      if (!(tab[i] > tab[i-1])){
        return false;
      }
    }
  } // end for
  for (int i = 1; i < 2*SIZE -1; i+=2) {
    if (!(tab[i+1] < tab[i] and tab[i] < tab[i+2])){
      if (!(tab[i] < tab[i+1])){
        return false;
      }
    }
  } // end for
  for (int i = 1; i < 2*SIZE; i+=2) {
    if (tab[i-1] >= tab[i]) {
      return false;
    }
  } // end for
  return true;
} //end check_overlaps


// Check if a read can be derived of the portion of a dna string
// @param s: the dna string
// @param t: the read string
// @param start: the starting index of the portion in the dna string (inclusive)
// @param end: the ending indix of the postion in the dna string (inclusive)
bool is_read_in_interval(string s, string t, int start, int end){
  int matches = 0;
  int cursor_t = 0;
  if(start >= end){
    return false;
  }
  if (start < 0) {
   return false;
  }
  if (end > s.length()-1) {
    return false;
  }
  if (s.length() < t.length()) {
    return false;
  }
  for (int i = start; i < end + 1) {
    if (s[i] == t[cursor_t) {
      cursor_t++;
      matches++;
    }
    if(matches == t.length()) {
      return true;
    }
  }
  return false;
} //end is_read_in_interval




// Returns first position of char `c` in `dna`
// starting at position `start_pos`. -1 if not found.
// Skip non-coding bits.
int find_pos(string& dna, int* dna_mask, char c, int start_pos) {
  for (int i = start_pos; i < dna.length(); i++) {
    if (dna_mask[i] == 0) continue;
    if (dna[i] == c) return i;
  }
  return -1;
}

// Returns position of the last char of `read` in `dna`
// starting at position `start_pos`. -1 if not found.
int is_substring(string& dna, int* dna_mask, string& read, int start_pos) {
  int last_pos = -1;
  for (int i = 0; i < read.length(); i++) {
    int pos = find_pos(dna, dna_mask, read[i], start_pos);
    if (pos == -1) return -1;
    start_pos = pos + 1;
    last_pos = pos;
  }
  return last_pos;
}
\end

\User CUDA:
\end

\Before everything else function:
if (argc != 2) {
  cout << "USAGE: ./rosalind FILE" << endl;
  exit(1);
}

ifstream infile(argv[1]);
infile >> DNA;
infile >> SIZE;
string line;
while ( getline(infile, line)) {
  if (line.length() > 0) {
    READS.push_back(line);
  }
}

assert(READS.size() == SIZE);

cout << "DNA <- " << DNA << endl;
cout << "SIZE <- " << SIZE << endl;
cout << "READS LONGUEUR" << READS.size() << endl;
for (int i = 0; i < READS.size(); i++) {
  cout << "READ " << i << " " << READS[i] << endl;
}

if (READS.size() != N_READS) {
  cout << "\n\nPLEASE EDIT N_READS TO MATCH THE NUMBER OF READS IN FILE: " << READS.size() << endl;
  exit(1);
}

\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass { 
  int read_positions[N_READS];
  int solutions[N_READS];
  int coding_bits[DNA_SIZE];
}
\end

\GenomeClass::display:
cout << "coucouille" << endl;
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  for(int i=0; i<SIZE; i++ ) {
    Genome.read_positions[i] = i;
  }
  random_shuffle(begin(Genome.read_positions), end(Genome.read_positions));
  for(int i=0; i<DNA_SIZE; i++ )
     	Genome.coding_bits[i] = random(0,2);
\end

\GenomeClass::crossover :

 int nLocus=random(1,DNA_SIZE);

  for (int i=nLocus;i<DNA_SIZE;i++)
     child.coding_bits[i]=parent2.coding_bits[i];
\end

\GenomeClass::mutator : // Must return a value (for historical reasons)
for (int i=0;i<DNA_SIZE;i++)
    if (tossCoin(pMutPerGene)) Genome.coding_bits[i]=(Genome.coding_bits[i]+1)%2;
  return 3;


\end

\GenomeClass::evaluator : // Returns the score
  float fScore = 0;
  int cursor = 0;

  for (int i = 0; i < SIZE; i++) {
    int read_idx = Genome.read_positions[i];
    int pos = is_substring(DNA, Genome.coding_bits, READS[read_idx], cursor);
    if (pos == -1) {
      Genome.solutions[i] = -1;
    } else {
      fScore++;
      Genome.solutions[i] = 1;
//      cursor = pos + 1;
    }
  }

  return fScore;
\end

\User Makefile options:
CXXFLAGS+=-std=c++11
\end

\Default run parameters :           // Please let the parameters appear in this order
  Number of generations : 100     // NB_GEN
  Time limit: 0                     // In seconds, 0 to deactivate
  Population size : 100            // POP_SIZE
  Offspring size : 100              // 40% 
  Mutation probability : 1          // MUT_PROB
  Crossover probability : 0.2       // XOVER_PROB
  Evaluator goal : maximise         // Maximise
  Selection operator: Tournament 2
  Surviving parents: 1              // Percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong                   // Weak or Strong
  Elite: 1
  Print stats: true
  Generate csv stats file: false			
  Generate gnuplot script: false
  Generate R script: false
  Plot stats: false

  Remote island model: false
  IP file: ip.txt                   // File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.3

  Save population: true
  Start from file: false
\end
