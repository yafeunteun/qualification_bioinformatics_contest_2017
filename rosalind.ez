/*_________________________________________________________

onemax.ez // Evolve individuals containing 111111111111111111...
__________________________________________________________*/


\User declarations :
#include<fstream>
#include<iostream>
#include<string>
#include<iterator>
#include<algorithm>
#include "assert.h"

#define N_READS 5
#define DNA_SIZE 69


int SIZE = 0;
string DNA = "";
vector<string> READS = vector<string>();
vector< vector< pair<int, int> > > MATRIX = vector< vector< pair<int, int> > >();

float pMutPerGene=0.1;
\end

\User functions:

// Check if in an array describing start and end positions,
// The overlaps are correct regarding of our problem
// return true if the overlaps are valids and false else.
// IMPORTANT: in our case `size` must be set to 2*SIZE
bool check_overlaps(int* tab, int size){
  for (int i = 2; i < size; i+=2) {
    if (!(tab[i-2] < tab[i] and tab[i] < tab[i-1])) {
      if (!(tab[i] > tab[i-1])){
        return false;
      }
    }
  } // end for
  for (int i = 1; i < 2*SIZE -1; i+=2) {
    if (!(tab[i+1] < tab[i] and tab[i] < tab[i+2])){
      if (!(tab[i] < tab[i+1])){
        return false;
      }
    }
  } // end for
  for (int i = 1; i < 2*SIZE; i+=2) {
    if (tab[i-1] >= tab[i]) {
      return false;
    }
  } // end for
  return true;
} //end check_overlaps


// Check if a read can be derived of the portion of a dna string
// @param s: the dna string
// @param t: the read string
// @param start: the starting index of the portion in the dna string (inclusive)
// @param end: the ending indix of the postion in the dna string (inclusive)
bool is_read_in_interval(string s, string t, int start, int end){
  int matches = 0;
  int cursor_t = 0;
  if(start >= end){
    return false;
  }
  if (start < 0) {
   return false;
  }
  if (end > s.length()-1) {
    return false;
  }
  if (s.length() < t.length()) {
    return false;
  }
  for (int i = start; i < end + 1; ++i) {
    if (s[i] == t[cursor_t]) {
      cursor_t++;
      matches++;
    }
    if(matches == t.length()) {
      return true;
    }
  }
  return false;
} //end is_read_in_interval




// Returns first position of char `c` in `dna`
// starting at position `start_pos`. -1 if not found.
// Skip non-coding bits.
int find_pos(string& dna, char c, int start_pos) {
  for (int i = start_pos; i < dna.length(); i++) {
    if (dna[i] == c) return i;
  }
  return -1;
}

// Returns position of the last char of `read` in `dna`
// starting at position `start_pos`. -1 if not found.
int is_substring(string& dna, string& read, int start_pos) {
  int last_pos = -1;
  for (int i = 0; i < read.length(); i++) {
    int pos = find_pos(dna, read[i], start_pos);
    if (pos == -1) return -1;
    start_pos = pos + 1;
    last_pos = pos;
  }
  return last_pos;
}
\end

\User CUDA:
\end

\Before everything else function:
if (argc != 2) {
  cout << "USAGE: ./rosalind FILE" << endl;
  exit(1);
}

ifstream infile(argv[1]);
infile >> DNA;
infile >> SIZE;
string line;
while ( getline(infile, line)) {
  if (line.length() > 0) {
    READS.push_back(line);
  }
}

assert(READS.size() == SIZE);

cout << "DNA <- " << DNA << endl;
cout << "SIZE <- " << SIZE << endl;
cout << "READS LONGUEUR" << READS.size() << endl;
for (int i = 0; i < READS.size(); i++) {
  cout << "READ " << i << " " << READS[i] << endl;
}

if (READS.size() != N_READS) {
  cout << "\n\nPLEASE EDIT N_READS TO MATCH THE NUMBER OF READS IN FILE: " << READS.size() << endl;
  exit(1);
}

for (int j = 0; j < READS.size(); j++) {
  cout << "Processing read " << j << endl;
  vector< pair<int, int> > pairs = vector< pair<int, int> >();
  string read = READS[j];

  for (int k = 0; k < DNA.length(); k++) {
    // Skip if the current position in the DNA
    // doesn't match the first letter of the read
    if (DNA[k] != read[0]) continue;

    // Search if the string is a substring in DNA
    // and get the last_pos (if any)
    int start_pos = k;
    int end_pos = is_substring(DNA, read, k);

    if (end_pos != -1) {
      // cout << "S:" << start_pos << " E:" << end_pos << " " << read << endl;
      pairs.push_back(pair<int, int>(start_pos, end_pos));
    }
  }

  cout << pairs.size() << " pairs for read " << j << endl;
  MATRIX.push_back(pairs);
}

\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass { 
//  int read_positions[N_READS];
//  int solutions[N_READS];
//  int coding_bits[DNA_SIZE];
  int orders[N_READS];
  int intervals[2*N_READS];
}
\end

\GenomeClass::display:
cout << "coucouille" << endl;
\end

\GenomeClass::initialiser : // "initializer" is also accepted
//  for(int i=0; i<SIZE; i++ ) {
//    Genome.orders[i] = i;
//  }
//  random_shuffle(begin(Genome.orders), end(Genome.orders));

  for(int i = 0; i < N_READS; i++){
    andomly_selected_interval_idx = random(0, MATRIX[i].length());
    Genome.intervals[2*i] = MATRIX[i][andomly_selected_interval_idx].first;
    Genome.intervals[(2*i)+1] = MATRIX[i][andomly_selected_interval_idx].second;
  }

\end

\GenomeClass::crossover :

 int nLocus=2*random(1,SIZE);

  for (int i=nLocus;i<2*SIZE;i++)
     child.intervals[i]=parent2.intervals[i];
\end

\GenomeClass::mutator : // Must return a value (for historical reasons)
 

  for (int i = 0; i < SIZE; ++i) {
    if (tossCoin(pMutPerGene)) {
      andomly_selected_interval_idx = random(0, MATRIX[i].length());
      Genome.intervals[2*i] = MATRIX[i][andomly_selected_interval_idx].first;
      Genome.intervals[(2*i)+1] = MATRIX[i][andomly_selected_interval_idx].second;
    } 
  }

  return 3;


\end

\GenomeClass::evaluator : // Returns the score
  float fScore = 0;

  if (!check_overlaps(Genome.intervals, 2*SIZE)){
    fScore = -10000;
  }

  for (int i = 0; i < N_READS; ++i) {
    if (is_read_in_interval(DNA, READS[Genome.orders[i]], Genome.intervals[2*i], Genome.intervals[(2*i)+1])) {
      fScore += 1;
    }
  }



  return fScore;
\end

\User Makefile options:
CXXFLAGS+=-std=c++11
\end

\Default run parameters :           // Please let the parameters appear in this order
  Number of generations : 1000     // NB_GEN
  Time limit: 0                     // In seconds, 0 to deactivate
  Population size : 1000            // POP_SIZE
  Offspring size : 1000              // 40% 
  Mutation probability : 1          // MUT_PROB
  Crossover probability : 0.2       // XOVER_PROB
  Evaluator goal : maximise         // Maximise
  Selection operator: Tournament 2
  Surviving parents: 1              // Percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong                   // Weak or Strong
  Elite: 1
  Print stats: true
  Generate csv stats file: false			
  Generate gnuplot script: false
  Generate R script: false
  Plot stats: false

  Remote island model: false
  IP file: ip.txt                   // File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.3

  Save population: true
  Start from file: false
\end
